<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Objetos en R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Pablo Andrés Guzmán" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="theme_bg_image.css" type="text/css" />
    <link rel="stylesheet" href="mi_slideTitulo.css" type="text/css" />
    <link rel="stylesheet" href="text_red.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: left, middle, my-title, title-slide

# Objetos en R
## ¿Porqué es importante diferenciarlos?
### Pablo Andrés Guzmán
### Universidad CES | Programa de Biología
### 22 Julio 2019

---





background-image: url(imagenes_fondo/ppt_2_cuerpo.png)
background-size: contain

# Contenido

.pull-left[
1. Objetos, sus tipos y sus clases

2. Filtrar o indexar objetos

3. Ejemplos de aplicación: 

    * Regresión logística
    * Análisis de Componentes Principales
    * Pruebas Chi-cuadrado
]

--

.pull-right[
Además, para la .red[sesión] se requiere:

- el archivo [`objetos.RData`](https://github.com/paguzmang/TalleresCursos/blob/master/07_22_Objetos/objetos.RData). 

- No usaremos ninguna librería fuera de las ya instaladas de base.
- Entre [aquí](https://github.com/paguzmang/TalleresCursos/tree/master/07_22_Objetos) para consultar el repositorio de esta presentación.
]

---
class: middle , center, inverse

background-image: url(imagenes_fondo/ppt_3_transicion.png)
background-size: contain


# Objetos, sus tipos y sus clases

---

background-image: url(imagenes_fondo/ppt_2_cuerpo.png)
background-size: contain

# Objetos, sus tipos y sus clases

.pull-left[
- El **R** es un lenguaje orientado a objetos. Todo es un objeto.

- Un objeto es un contenedor de información.

- Tipos principales de objetos:

    + Vectores
    + Matrices y arreglos
    + Marcos de datos (data.frame)
    + Listas
    + Factores
    + Funciones o comandos
]

.pull-right[
![:scale 70%](imagenes_fondo/caja.png)
]



---

## Objetos, sus tipos y sus clases

### Vectores
  * Se crean con el comando: `c`.
  * Almacenan datos de un sólo tipo.
  * No tienen dimensión.

### Matrices y arreglos
  * Se crean con los comandos: `matrix`, `cbind`, `rbind`, `array`.
  * Almacenan datos de un sólo tipo.
  * Tienen dimensión: filas (1), columnas (2), etc. Un arreglo se puede ver como un vector al cual se le asigna dimensión.


    
---

## Objetos, sus tipos y sus clases

### Marcos de datos (data.frame)
  * Se crean con el comando: `data.frame` o cuando importamos datos con `read.table`, `read.csv`, etc.
  * Almacenan datos de múltiples tipos. Cada columna es un vector.
  * Tienen dimensión: filas (1) y columnas (2).

### Listas
  * Se crean con el comando: `list`.
  * Pueden almacenar cualquier tipo de objeto.
  * No tienen dimensión (igual que vectores).

---

## Objetos, sus tipos y sus clases

### Actividad: Creación y cálculos con vectores

+ Crear y establecer un directorio de trabajo en **Rstudio**. Llamelo `NotasCurso_nombre`, donde la palabra `nombre` remplacela por su nombre (p.e., `NotasCurso_pguzman`).

+ Dentro del directorio de trabajo, cree un nuevo script de código. Llamelo `NotasCurso_pguzman`. Note que este archivo quedará con extensión `.R`.

+ Utilice el script para realizar los cálculos necesarios para obtener la nota final del curso de los siguientes tres estudiantes:

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:center;"&gt; Estudiante &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; Nota 1 (15%) &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; Nota 2 (25%) &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; Nota 3 (30%) &lt;/th&gt;
   &lt;th style="text-align:center;"&gt; Nota 4 (30%) &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:center;"&gt; A &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 2.8 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 3.5 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 4.1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 3.8 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:center;"&gt; B &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 2.1 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 1.5 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 2.5 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 3.2 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:center;"&gt; C &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 4.3 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 3.9 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 3.8 &lt;/td&gt;
   &lt;td style="text-align:center;"&gt; 4.1 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

---

## Objetos, sus tipos y sus clases

### Actividad: Creación y cálculos con vectores

+ En el script cree un vector por estudiante que contengan las cuatro notas parciales, cree otro vector para los porcentajes y, realice el cálculo respectivo para obtener un vector para la nota final.

+ Usando el comando `save` o `save.image` guarde todos los objetos creados con el nombre `notas_nombre.RData` (la palabra nombre reemplacela por su nombre).

+ Guarde su script y cierre **Rstudio**. Abre de nuevo la sesión y verifique que tanto el script (`.R`) como los objetos (`.RData`) estan bien.

---

## Objetos, sus tipos y sus clases

### Ejemplo


```r
load('objetos.RData')  # se cargan los objetos
ls()                   # imprimir el nombre de los objetos
```

```
 [1] "AG"          "BK"          "CD"          "d"           "descrip_obj"
 [6] "ecoli"       "FM"          "LC"          "lovett"      "SS"         
[11] "YR"         
```

Examinemos el tipo y clase de algun objeto con la función o comando .red[`descrip_obj`]:


```r
descrip_obj(x = ecoli)  # Tipo, clase y modo de 'ecoli'
```

```
  typeof  class    mode length
1 double matrix numeric     15
```

---

## Objetos, sus tipos y sus clases

Al aplicar la función .red[`descrip_obj`] a cada objeto, obtenemos lo siguiente:

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; objeto &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; typeof &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; class &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; mode &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; length &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; FM &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; character &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; character &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; character &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 147 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; SS &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; character &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; character &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; character &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 147 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; lovett &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; list &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; data.frame &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; list &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 17 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; d &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; list &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; data.frame &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; list &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 5 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; BK &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; integer &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; factor &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; numeric &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 147 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; descrip_obj &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; closure &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; function &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; function &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; CD &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; integer &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; integer &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; numeric &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 147 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; AG &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; integer &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; integer &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; numeric &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 147 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; YR &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; integer &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; integer &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; numeric &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 147 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; ecoli &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; double &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; matrix &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; numeric &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 15 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; LC &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; double &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; numeric &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; numeric &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 147 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

---

## Objetos, sus tipos y sus clases

### Ejercicio

Use los comandos .red[`is.vector`], .red[`is.matrix`], .red[`is.data.frame`], etc. sobre algunos de los objetos. Ellos devuelven `TRUE` o `FALSE` según corresponda.

---

class: middle , center, inverse

background-image: url(imagenes_fondo/ppt_3_transicion.png)
background-size: contain


# Filtrar o indexar objetos

---
## Filtrar o indexar objetos

### Vectores

Usaremos los vectores `AG`, `FM`, `BK` y `LC` para mostrar manipulación, creación y filtro de vectores y factores. Estos vectores (junto a `SS`, `CD` y `YR`) hacen parte de un conjunto de datos sobre un estudio caso-cantrol que buscó identificar asociación entre el cáncer de pulmón y la tenencia de aves como mascotas en Holada. El estudio incluyó 147 sujetos en total, 49 de ellos con cáncer de pulmon. Una descripción de los vectores es la siguiente:

- `AG` = Edad (años) del sujeto.
- `FM` = Sexo del sujeto.
- `BK` = Indicador de tenedor de aves (`Bird`) como mascota o no (`NoBird`).
- `LC` = Indica si el sujeto tiene (`1`) cáncer de pulmón o no (`0`)

Ver una mayor descripción del estudio y de cada variable (vector) [aquí](https://www.rdocumentation.org/packages/Sleuth2/versions/2.0-5/topics/case2002).

---

## Filtrar o indexar objetos

### Vectores numéricos y de texto

.pull-left[


```r
# Vector numerico
AG[c(1, 4, 9)]  # por posicion
```

```
[1] 37 46 56
```

```r
AG[-(1:140)]    # por posicion neg.
```

```
[1] 61 62 62 63 64 64 65
```

```r
AG[AG &lt; 40 ]    # por expres. logica
```

```
[1] 37 37 38
```
 

]

.pull-right[


```r
# vector de texto
FM[c(1, 4, 9)]  # por posicion
```

```
[1] "Male" "Male" "Male"
```

```r
FM[-(1:141)]  # por posicion negativa
```

```
[1] "Female" "Female" "Female" "Female" "Female" "Female"
```

]

---

## Filtrar o indexar objetos

### Vectores de clase Factor (Factores)


```r
# Factor
BK[c(1, 4, 9)]  # por posicion
```

```
[1] Bird Bird Bird
Levels: NoBird Bird
```

```r
BK[FM == 'Female']  # por expres. logica
```

```
 [1] Bird   Bird   Bird   Bird   Bird   Bird   Bird   Bird   Bird   Bird  
[11] NoBird NoBird NoBird Bird   Bird   Bird   Bird   NoBird NoBird NoBird
[21] Bird   Bird   Bird   NoBird Bird   NoBird Bird   NoBird Bird   NoBird
[31] Bird   Bird   NoBird NoBird NoBird NoBird
Levels: NoBird Bird
```
 
---

## Filtrar o indexar objetos

### ¿Qué objeto resulta al filtrar factores?


```r
BK.nuevo &lt;- BK[c(1,4, 9)]  # filtro y se guarda
BK.nuevo                   # se imprime
```

```
[1] Bird Bird Bird
Levels: NoBird Bird
```

```r
descrip_obj(BK.nuevo)      # se examina el tipo de objeto
```

```
   typeof  class    mode length
1 integer factor numeric      3
```

Note que el .red[`BK.nuevo`] sigue siendo un .red[factor] con .red[dos] niveles a pesar de que todos sus tres elementos son `Bird`. Para quitar niveles no usados, utilice el comando .red[`droplevels`] (Ejemplo: `droplevels(BK.nuevo)`).

---

## (Creando factores)

Un factor se crea a partir de un vector de texto (`character`) o numérico usando el comando .red[`factor`]:


```r
FM.fac &lt;- factor(FM, levels = c('Male', 'Female'), labels = c('male', 'female'))
table(FM.fac)  # tabla de frecuencias sobre el factor creado
```

```
FM.fac
  male female 
   111     36 
```

Los argumentos `levels` y `labels` son opcionales.

### Ejercicios

- ¿Para qué sirven los argumentos `levels` y `labels`?

- Cree un nuevo factor usando el vector `LC`. En este vector, el valor `1` indica `cancerPul` y `0` indica `control`. Asigne estas dos etiquetas al factor creado.


---

## Filtrar o indexar objetos

### Matrices

Usaremos el objeto `ecoli` el cual es una matriz de 3 filas y 5 columnas que almacena una tabla de _conteos_ del número de muestras de agua contaminadas con la bacteria _E. coli_ de acuerdo a la locación y a la fuente animal de la cual proviene la bacteria.


```r
ecoli   # se imprime para ver el objeto
```

```
   fuente
loc aves mascotas anim_granja humanos mamif_ter
  A   46       29         106      38        22
  B   79       56          32      63        26
  C   35       23           0      60         8
```

```r
descrip_obj(ecoli)  # tipo, clase y modo
```

```
  typeof  class    mode length
1 double matrix numeric     15
```

---

### Matrices


```r
dim(ecoli)          # dimension: nro. de filas y nro. de col
```

```
[1] 3 5
```

```r
addmargins(ecoli)   # se agregan totals de fila y col
```

```
     fuente
loc   aves mascotas anim_granja humanos mamif_ter Sum
  A     46       29         106      38        22 241
  B     79       56          32      63        26 256
  C     35       23           0      60         8 126
  Sum  160      108         138     161        56 623
```

Funciona también `addmargins(ecoli, margin = 1)` o `addmargins(ecoli, margin = 2)` para agregar sólo uno de los dos totales.

---

### Matrices


```r
colSums(ecoli)     # totales por columna
```

```
       aves    mascotas anim_granja     humanos   mamif_ter 
        160         108         138         161          56 
```

```r
rowSums(ecoli)     # totales por fila
```

```
  A   B   C 
241 256 126 
```

```r
prop.table(ecoli)  # prop. dividiendo por gran total (nota: considere argumento margin)
```

```
   fuente
loc       aves   mascotas anim_granja    humanos  mamif_ter
  A 0.07383628 0.04654896  0.17014446 0.06099518 0.03531300
  B 0.12680578 0.08988764  0.05136437 0.10112360 0.04173355
  C 0.05617978 0.03691814  0.00000000 0.09630819 0.01284109
```

---

### Matrices


```r
chisq.test(ecoli)  # Prueba Chi-cuadrado de Independencia
```

```

	Pearson's Chi-squared test

data:  ecoli
X-squared = 138.62, df = 8, p-value &lt; 2.2e-16
```

---

## Filtrar o indexar objetos

### Matrices

.pull-left[

```r
ecoli  # Se imprime
```

```
   fuente
loc aves mascotas anim_granja humanos mamif_ter
  A   46       29         106      38        22
  B   79       56          32      63        26
  C   35       23           0      60         8
```

```r
ecoli[2, 3]  # por posicion (filas, columnas)
```

```
[1] 32
```
]

.pull-right[

```r
ecoli[,  3]  # toda la 3era. col.
```

```
  A   B   C 
106  32   0 
```

```r
ecoli[, c(2,3)] # cols. 2 y 3
```

```
   fuente
loc mascotas anim_granja
  A       29         106
  B       56          32
  C       23           0
```
]

---

## Filtrar o indexar objetos

### Matrices: ejercicios

1. Indique la clase de objeto en cada filtro:

    + `ecoli[c(1,3), c(2, 5)]`

    + `ecoli[2, ]`

    + `ecoli[c('B','C'), c('aves', 'humanos')] # filtro con nombres de fila o columna`

2. Escriba el filtro que genere la siguiente impresión:


```
   fuente
loc mamif_ter anim_granja
  C         8           0
  B        26          32
```


---
## Filtrar o indexar objetos

### data.frame

A continuación usaremos el `data.frame` .red[`lovett`] el cual almacena variables topográficas y químicas del agua de 38 quebradas en cierta zona montañosa de Estados Unidos. Alguna información del data.frame es la siguiente:


```r
descrip_obj(lovett)   # tipo, clase y modo del objeto
```

```
  typeof      class mode length
1   list data.frame list     17
```

```r
dim(lovett)           # dimension: nro. filas y nro. col
```

```
[1] 38 17
```

---

## Filtrar o indexar objetos

### data.frame

A continuación usaremos el `data.frame` .red[`lovett`] el cual almacena variables topográficas y químicas del agua de 38 quebradas en cierta zona montañosa de Estados Unidos. Alguna información del data.frame es la siguiente:


```r
names(lovett)         # nombres de las columnas
```

```
 [1] "STREAM"   "MAXELEV"  "SAMPELEV" "LENGTH"   "AREA"     "NO3"     
 [7] "TON"      "TN"       "NH4"      "DOC"      "SO4"      "CL"      
[13] "CA"       "MG"       "H"        "r2.NH4"   "r4.H"    
```

---

## Filtrar o indexar objetos

### data.frame

Se puede filtrar igual que una matriz, usando posiciones de fila o de columna, o nombres de columna o de fila. Algunos ejemplos


```r
lovett[1:3, c(1,5,6)]  # filas 1 a 3, columnas 1,5,6
```

```
      STREAM AREA  NO3
1 Santa Cruz   23 24.2
2    Colgate  462 25.4
3     Halsey  297 29.7
```

```r
lovett[1:3, c('STREAM', 'AREA', 'NO3')]  # Lo mismo usando nombres de col
```

```
      STREAM AREA  NO3
1 Santa Cruz   23 24.2
2    Colgate  462 25.4
3     Halsey  297 29.7
```

---

## Filtrar o indexar objetos

### data.frame

Una columna entera  se puede sacar (como vector) usando el signo  pesos (.red[`$`]) después del nombre del data.frame y seguido del nombre de la columna:


```r
lovett$STREAM   # es equivalente a lovett[, 'STREAM']
```

```
 [1] "Santa Cruz"   "Colgate"      "Halsey"       "Batavia Hill"
 [5] "Windham Ridg" "Silver Sprin" "Little Timbe" "Hunter"      
 [9] "West Kill"    "Mill"         "Kelly Hollow" "Pigeon"      
[13] "Biscuit"      "Fall"         "Bear Hole"    "Buttermilk F"
[17] "Rondout"      "Kanape"       "Woodland Val" "Broadst Holl"
[21] "Pecoy"        "Prediger"     "Bear Pen"     "Weaver"      
[25] "BWS6"         "Halcott"      "Tonshi"       "Grog Kill"   
[29] "Hollow Tree"  "Lost Clove"   "Black"        "Styles"      
[33] "Warners"      "Kittle"       "Traver Hollo" "Willowemoc"  
[37] "Myrtle"       "Becker Hollo"
```

---

## Filtrar o indexar objetos

### data.frame

Usando el comando .red[`subset(data, subset, select)`] donde el argumento `data` es el data.frame, el argumento `subset` es un filtro (lógico) para las filas y el argumento `select` es un filtro para las columnas.


```r
# Filtro para las filas de acuerdo al H
subset(lovett, subset = H &gt; 0.8, select = c(STREAM, AREA, NO3, H))
```

```
     STREAM AREA  NO3    H
17  Rondout 1686 23.4 1.33
22 Prediger  125 21.5 1.14
```

- Note que el comando (`subset`) y el argumento se llaman igual (pero usar el nombre del argumento no es obligatorio)
- El argumento `select` es opcional. Ademas, de usarse, las variables no requieren ir entre comillas.

---

## Filtrar o indexar objetos

### data.frame: ejercicios

- En cada caso, describa el filtro e identifique el tipo de objeto resultante después del filtro:

    - `lovett[, 'NO3']`
    - `lovett[10:15, 'NO3']`
    - `lovett[10:15, c('NO3', 'H')]`
    - `lovett$TON`
    - `head(lovett)`
    - `tail(lovett)`
    - `lovett$DOC[1:3]`
    - `subset(lovett, NO3 &lt;= 15, NO3)`
    - `subset(lovett, NO3 &lt;= 15, c(STREAM, NO3))`

---
## Filtrar o indexar objetos

### data.frame: ejercicios (continuación)

- Filtre la tabla por aquellas filas que tengan un valor de `TN` (Nitrogeno total) mayor a 40 y que la tabla resultante sólo tenga las columnas `STREAM`, `AREA` y `TN`.

- El siguiente código intenta realizar un diagrama de dispersión entre las variables `NO3` y `r2.NH4`. El código es: `plot(x = NO3, y = r2.NH4)`. Sin embargo, al ejecutarse sale un error. Explique el error y corrija el código.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macro_scale.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
